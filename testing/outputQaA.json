[
  {
    "question": "What cipher block modes are supported by the AES hardware IP in OpenTitan, and how is Galois/Counter Mode (GCM) handled?",
    "answer": "According to the provided context, the AES hardware IP block in OpenTitan supports five cipher block modes: ECB, CBC, CFB, OFB, and CTR, with key lengths of 128, 192, and 256 bits [Source 4](https://opentitan.org/book/hw/top/earlgrey/doc/design/index.html)](https://opentitan.org/book/hw/top/earlgrey/doc/design/index.html). \n\nGalois/Counter Mode (GCM) is not directly supported by the AES hardware IP. Instead, GCM can be implemented using the Ibex processor for the GHASH operation, as demonstrated in the OpenTitan Cryptography Library. To improve GCM performance, instructions from the RISC-V Bit-Manipulation Extension of Ibex, particularly carry-less multiply instructions, can be leveraged to speed up the GHASH operation [Source 3](https://opentitan.org/book/hw/ip/aes/index.html)](https://opentitan.org/book/hw/ip/aes/index.html)."
  },
  {
    "question": "How does the AES unit in OpenTitan balance performance and security, and what compile-time configurations are available?",
    "answer": "The AES unit in OpenTitan supports key sizes of 128, 192, and 256 bits to balance performance and security needs [Source 5](https://opentitan.org/book/hw/top/earlgrey/doc/design/index.html)](https://opentitan.org/book/hw/top/earlgrey/doc/design/index.html). It can perform encryption and decryption on 16-byte data blocks using various block cipher modes including ECB, CBC, CFB, OFB, CTR, and GCM [Source 5](https://opentitan.org/book/hw/top/earlgrey/doc/design/index.html)](https://opentitan.org/book/hw/top/earlgrey/doc/design/index.html).\n\nBy default, the AES unit is controlled entirely by the processor. The processor writes the input data and initial key to dedicated registers via the system bus [Source 7](https://opentitan.org/book/hw/ip/aes/doc/theory/of/operation.html)](https://opentitan.org/book/hw/ip/aes/doc/theory/of/operation.html). \n\nThe context does not provide specific information on compile-time configuration options for the AES unit. Cost estimates in terms of gate count for supporting 192-bit mode are being evaluated to decide whether to include it in OpenTitan, as systems requiring security above 128-bit typically use 256-bit AES directly [Source 7](https://opentitan.org/book/hw/ip/aes/doc/theory/of/operation.html)](https://opentitan.org/book/hw/ip/aes/doc/theory/of/operation.html)."
  },
  {
    "question": "What is the purpose of the otbn_core_model in the OTBN DV testbench, and how does it aid in verifying correctness?",
    "answer": "The otbn_core_model in the OTBN DV testbench wraps an instruction set simulator (ISS) subprocess and performs checks to make sure that the OTBN RTL behaves the same as the ISS [Information from context]](https://opentitan.org/book/hw/ip/otbn/dv/index.html). The otbn_core_model communicates with test sequences through an otbn_model_if interface, which is monitored by the otbn_model_agent [Information from context]](https://opentitan.org/book/hw/ip/otbn/dv/index.html).\n\nMuch of the checking for the OTBN tests is performed in the otbn_core_model, which ensures that the RTL and ISS have the same behavior. However, the scoreboard in the testbench does have some additional checks, to ensure that interrupt and idle signals are high at the expected times [Information from context]](https://opentitan.org/book/hw/ip/otbn/dv/index.html).\n\nSo in summary, the otbn_core_model aids verification by checking that the OTBN RTL matches the behavior of the ISS reference model. This is a key part of the self-checking strategy in the OTBN DV testbench."
  },
  {
    "question": "What are the primary capabilities and limitations of the HMAC hardware IP in OpenTitan?",
    "answer": "Based on the provided context, the key capabilities and limitations of the HMAC hardware IP in OpenTitan are:\n\nCapabilities:\n- Supports two modes: SHA-2 hashing and HMAC based on SHA-2 [Source 1](https://opentitan.org/book/hw/ip/hmac/index.html)](https://opentitan.org/book/hw/ip/hmac/index.html)\n- Conforms to the OpenTitan guideline for peripheral device functionality [Source 1](https://opentitan.org/book/hw/ip/hmac/index.html)](https://opentitan.org/book/hw/ip/hmac/index.html)\n- Supports HMAC-SHA256 with a key length of 256 bits [Source 6](https://opentitan.org/book/doc/security/cryptolib/cryptolib/api.html)](https://opentitan.org/book/doc/security/cryptolib/cryptolib/api.html)\n- Has a TileLink-UL bus device interface for integration into the OpenTitan system [Source 5](https://opentitan.org/book/hw/ip/hmac/doc/interfaces.html)](https://opentitan.org/book/hw/ip/hmac/doc/interfaces.html)\n\nLimitations:\n- Does not appear to support other HMAC variants besides HMAC-SHA256\n- Key size is fixed at 256 bits for HMAC-SHA256, no flexibility in key length [Source 6](https://opentitan.org/book/doc/security/cryptolib/cryptolib/api.html)](https://opentitan.org/book/doc/security/cryptolib/cryptolib/api.html)\n\nThe context does not provide additional details on performance, throughput, or other potential limitations. The design verification goals [Source 7](https://opentitan.org/book/hw/ip/hmac/dv/index.html)](https://opentitan.org/book/hw/ip/hmac/dv/index.html) indicate the IP is still undergoing testing to achieve full functional and code coverage."
  },
  {
    "question": "What I2C protocol features and operational modes are supported by the I2C hardware IP in OpenTitan?",
    "answer": "The I2C hardware IP in OpenTitan supports the following features and operational modes:\n\n- Two-pin clock-data parallel bidirectional external interface: SCL (serial clock line) and SDA (serial data line) [Source 1](https://opentitan.org/book/hw/ip/i2c/index.html)](https://opentitan.org/book/hw/ip/i2c/index.html)\n\n- Can function as both an I2C controller and/or an I2C target, enabled at runtime by setting the CTRL.ENABLEHOST and CTRL.ENABLETARGET register fields [Source 2](https://opentitan.org/book/hw/ip/i2c/doc/theory/of/operation.html)](https://opentitan.org/book/hw/ip/i2c/doc/theory_of_operation.html)\n\n- Supports Standard-mode (100 kbaud), Fast-mode (400 kbaud) and Fast-mode Plus (1 Mbaud) speeds\n\n- Bandwidth up to 1 Mbaud\n\n- Supports mandatory I2C controller features per the I2C specification revision 6: Start condition, Stop condition, Acknowledge (ACK), 7-bit target address \n\n- Supports optional clock stretching capability in controller mode\n\n[Source 1](https://opentitan.org/book/hw/ip/i2c/index.html)](https://opentitan.org/book/hw/ip/i2c/index.html)\n[Source 2](https://opentitan.org/book/hw/ip/i2c/doc/theory/of/operation.html)](https://opentitan.org/book/hw/ip/i2c/doc/theory_of_operation.html)"
  },
  {
    "question": "What cryptographic functions and side-channel protections are provided by the KMAC HWIP, and how can a DV engineer expect it to behave in masked vs unmasked modes?",
    "answer": "The KMAC HWIP provides the following cryptographic hash and message authentication code (MAC) functions [Source 7](https://opentitan.org/book/sw/device/lib/dif/dif/kmac/h.html)](https://opentitan.org/book/sw/device/lib/dif/dif/kmac/h.html):\n\n- SHA-3 \n- SHAKE\n- cSHAKE\n- KMAC\n\nIt uses the Keccak sponge construction to implement these functions [Source 1](https://opentitan.org/book/hw/ip/kmac/index.html)](https://opentitan.org/book/hw/ip/kmac/index.html).\n\nFor side-channel attack protection, the KMAC HWIP implements a defense mechanism expected to protect against 1st-order attacks by using masked storage and Domain-Oriented Masking (DOM) [Source 1](https://opentitan.org/book/hw/ip/kmac/index.html)](https://opentitan.org/book/hw/ip/kmac/index.html).\n\nIn masked mode (when the EnMasking compile-time parameter is set), the secret key is provided by the KeyMgr in two-share masked form. The software provides the secret key as two XOR shares. In unmasked mode, the key is provided directly with encoded values [Source 3](https://opentitan.org/book/hw/ip/kmac/doc/theory/of/operation.html)](https://opentitan.org/book/hw/ip/kmac/doc/theory/of/operation.html).\n\nSo in summary, a DV engineer can expect the KMAC HWIP to implement standard hash and MAC functions using a sponge construction, with the ability to operate in a side-channel resistant masked mode or a regular unmasked mode depending on the EnMasking parameter and how the secret key is supplied."
  },
  {
    "question": "What is DVSim in OpenTitan, and what tool flows does it manage?",
    "answer": "According to the provided context, DVSim is a tool used in the OpenTitan project to manage EDA tool flows for design verification [Source 1](https://opentitan.org/book/util/dvsim/index.html)](https://opentitan.org/book/util/dvsim/index.html). It is written in Python and relies on several third-party Python libraries, such as Hjson for parsing configuration data, Enlighten for tracking tool flow progress, Mistletoe for converting Markdown to HTML, Premailer for inlining CSS into generated HTML reports, and Tabulate for pretty-printing tabular data [Source 1](https://opentitan.org/book/util/dvsim/index.html)](https://opentitan.org/book/util/dvsim/index.html), [Source 3](https://opentitan.org/book/util/dvsim/doc/design/doc.html)](https://opentitan.org/book/util/dvsim/doc/design/doc.html)."
  },
  {
    "question": "How are clocks managed across different groups in OpenTitan, and what role does software play in clock control?",
    "answer": "In OpenTitan, clocks are managed differently across various groups, with software having minimal control to reduce risks in clock manipulation [Source 2](https://opentitan.org/book/hw/top/earlgrey/ip/autogen/clkmgr/index.html)](https://opentitan.org/book/hw/top/earlgrey/ip/autogen/clkmgr/index.html).\n\nFor the security clock group specifically, which includes modules with background functions (entropy, alert manager, sensors) or critical security functions (life cycle, otp, pinmux, plic), no software influence over the clock state is allowed during the active state. The clocks in this group are always running as long as the source is on [Source 1](https://opentitan.org/book/hw/top/earlgrey/ip/autogen/clkmgr/doc/theory/of/operation.html)](https://opentitan.org/book/hw/top/earlgrey/ip/autogen/clkmgr/doc/theory/of/operation.html).\n\nThe OpenTitan power and clock managers are responsible for manipulating the clock enables and observing the valid signals to know when clocks can be safely released to the system [Source 3](https://opentitan.org/book/hw/top/earlgrey/ip/ast/index.html)](https://opentitan.org/book/hw/top/earlgrey/ip/ast/index.html). However, the specific roles and control that software has over clocks in groups other than the security group are not detailed in the provided citable sources."
  },
  {
    "question": "How are interrupts and alerts standardized and implemented across OpenTitan peripherals?",
    "answer": "In OpenTitan, interrupts and alerts are standardized across peripherals to provide a consistent interface:\n\nInterrupts use common naming, hardware interfaces, and software interfaces where possible. Currently, OpenTitan uses active-high level-triggered interrupts. Generic hardware (prim_intr_hw) is defined to generate interrupt requests of two types - Event type for instantaneous events, and Status type for persistent conditions. [Source 1](https://opentitan.org/book/doc/contributing/hw/comportability/index.html)](https://opentitan.org/book/doc/contributing/hw/comportability/index.html)\n\nAlerts also have a standardized interface. Each peripheral lists the alerts it generates in the alert_list attribute of its configuration file. The alert handler then generates corresponding signals to communicate between the alert sender and handler for each alert in the system. [Source 1](https://opentitan.org/book/doc/contributing/hw/comportability/index.html)](https://opentitan.org/book/doc/contributing/hw/comportability/index.html)\n\nSo in summary, interrupts and alerts use uniform register, hardware and software interfaces defined in the Comportability Specification to enable consistent implementation across OpenTitan peripherals."
  },
  {
    "question": "What is the recommended process for starting a new hardware design in OpenTitan?",
    "answer": "Based on the provided context, the recommended process for starting a new hardware design in OpenTitan is:\n\n1. The new design is typically a new \"Comportable Peripheral\", as mentioned in [Source 1](https://opentitan.org/book/doc/contributing/hw/design.html)](https://opentitan.org/book/doc/contributing/hw/design.html) and [Source 3](https://opentitan.org/book/doc/contributing/hw/index.html)](https://opentitan.org/book/doc/contributing/hw/index.html). \n\n2. Key steps include reviewing the Comportability, Hardware Design, and Design Methodology guides, as outlined in [Source 3](https://opentitan.org/book/doc/contributing/hw/index.html)](https://opentitan.org/book/doc/contributing/hw/index.html).\n\n3. The design should be verified using dynamic simulations with functional tests and Formal Property Verification (FPV), according to the verification methodology described in [Source 4](https://opentitan.org/book/doc/contributing/dv/methodology/index.html)](https://opentitan.org/book/doc/contributing/dv/methodology/index.html).\n\nSo in summary, start by understanding the Comportability requirements, follow the hardware design and methodology guides, and plan for verification using the standard OpenTitan techniques of dynamic simulation and FPV."
  },
  {
    "question": "How should developers work with hardware code from external repositories in the OpenTitan project?",
    "answer": "According to [Source 1](https://opentitan.org/book/doc/contributing/hw/vendor.html)](https://opentitan.org/book/doc/contributing/hw/vendor.html), OpenTitan incorporates code from third parties and splits out pieces of its own code to external repositories. Developers need to import and use code from these external repositories in the OpenTitan code base.\n\nThe source states that code from external repositories is placed in subdirectories of hw/vendor. It provides step-by-step instructions for common tasks related to working with external hardware code repositories.\n\nSo in summary, OpenTitan developers work with external hardware code by importing it into the hw/vendor directory of the OpenTitan monorepo, following the provided instructions. This allows seamless integration of third-party and externally maintained OpenTitan code into the main project."
  },
  {
    "question": "What is Ipgen in OpenTitan and how does it help generate IP blocks?",
    "answer": "According to the provided context, Ipgen is a tool in OpenTitan used to generate IP blocks from IP templates [Source 1](https://opentitan.org/book/util/ipgen/index.html)](https://opentitan.org/book/util/ipgen/index.html). It can be used as a command-line tool or a Python library.\n\nThe output produced by Ipgen is determined by the chosen renderer, with the IpBlockRenderer being the right choice for most use cases as it produces a full IP block directory [Source 1](https://opentitan.org/book/util/ipgen/index.html)](https://opentitan.org/book/util/ipgen/index.html).\n\nIpgen is an important part of the IP block generation process in OpenTitan. The generation of Ipgen peripherals is delicate since they depend on each other, with all the dependencies captured in the top configuration. The order in which Ipgen peripherals are expanded needs to be carefully chosen to avoid multiple generation passes [Source 5](https://opentitan.org/book/util/topgen/index.html)](https://opentitan.org/book/util/topgen/index.html).\n\nIn summary, Ipgen helps automate the generation of IP blocks in OpenTitan based on pre-defined IP templates, handling the intricate dependencies between peripherals."
  },
  {
    "question": "What does the uvmdvgen tool do in the OpenTitan verification flow?",
    "answer": "According to the provided context, the uvmdvgen tool is used in the OpenTitan verification flow to auto-generate the initial UVM testbench for a new design under test (DUT). Specifically:\n\n- uvmdvgen is a verification starter tool-kit that can completely auto-generate the initial DV environment for a new DUT, including documentation. [Source 2](https://opentitan.org/book/doc/contributing/dv/methodology/index.html)](https://opentitan.org/book/doc/contributing/dv/methodology/index.html)\n\n- The motivation for using uvmdvgen is to enable code reuse and conformity across OpenTitan's verification efforts. [Source 2](https://opentitan.org/book/doc/contributing/dv/methodology/index.html)](https://opentitan.org/book/doc/contributing/dv/methodology/index.html) \n\n- uvmdvgen is described as an \"initial testbench auto-generation tool\". [Source 1](https://opentitan.org/book/util/uvmdvgen/index.html)](https://opentitan.org/book/util/uvmdvgen/index.html)\n\nSo in summary, uvmdvgen jump-starts the UVM testbench development process for new OpenTitan IP blocks by automatically creating an initial, reusable testbench code framework. This promotes consistency and efficiency in the OpenTitan verification methodology."
  },
  {
    "question": "What are the health checks and operating modes of the ENTROPY_SRC IP in OpenTitan?",
    "answer": "Based on the provided context, the ENTROPY_SRC IP block in OpenTitan performs health tests on collected entropy bits before storing them in a FIFO to be consumed by hardware or software interfaces [Source 5](https://opentitan.org/book/hw/ip/entropy/src/index.html)](https://opentitan.org/book/hw/ip/entropy/src/index.html).\n\nThe ENTROPY_SRC block provides a software API to configure entropy source health test features with runtime information. This is done using the `dif_entropy_src_health_test_configure` function, which takes an entropy source handle and a `dif_entropy_src_health_test_config` struct containing the health test type and threshold parameters [Source 1](https://opentitan.org/book/sw/device/lib/dif/dif/entropy/src/h.html)](https://opentitan.org/book/sw/device/lib/dif/dif/entropy/src/h.html).\n\nTo initialize the ENTROPY_SRC block, Device Interface Functions (DIFs) are used. Once initialized, the block can deliver entropy to be consumed by either a CSRNG hardware instance or a CSRNG software instance [Source 4](https://opentitan.org/book/hw/ip/entropy/src/doc/programmers/guide.html)](https://opentitan.org/book/hw/ip/entropy/src/doc/programmers/guide.html)."
  }
]